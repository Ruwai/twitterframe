'''	Was going to add this to the twitter_methods.py but this will just be cleaner.	Might make it more efficient...	From what I know about this StreamListener class is that it is required that	create a subclass that inherits the methods from tweepy.StreamListener.	The source code for StreamListener can be found here:	https://github.com/tweepy/tweepy/blob/master/tweepy/streaming.py#L31	From there we make our actual methods that route to our commands with	the class Stream() that has a ton of stuff in the init...	https://github.com/tweepy/tweepy/blob/master/tweepy/streaming.py#L190'''from . import utilsimport tweepyimport osimport pathlib as Pathimport jsonimport csvimport sqlite3import psychopg2from Queue import Queue, Emptyfrom threading import Thread, Eventimport crayonsh = utils.hatching_chickb = utils.baby_chickp = utils.partypidgeon = utils.pidgeonw = utils.warningcheck = utils.checkmarkegg = utils.eggsheep = utils.sheepQUEUE_S_TIMEOUT = 1API_S_RETRY = 60API_S_RETRY_DELAY = 1API_RETRY_ERR = [400,401,500,502,503,504]class StreamListener(tweepy.StreamListener):    '''    Stream Listener class.    '''    def __init__(self, user_id, tracker, callback):      self.user_id = user_id      self.tracker = tracker      self.callback = callback      self.error_status = None      self.start_queue()    def start_queue(self):      '''        Creates a queue and starts the worker threads.      '''      self.queue = Queue()      self.stop_event = Event()      self.worker = Thread(target=self.process_queue)      self.worker.daemon = True      self.worker.start()    def stop_queue(self):      '''        Shuts down the queue and worker threads.      '''      if self.queue:        print('Stopping queue.')        self.queue.join()      else:        print('No queue to stop.')      print('Stopping worker thread.')      self.stop_event.set()      self.worker.join()    def process_queue(self):      '''        Continuously processses tasks on the queue.      '''      while not self.stop_event.is_set():        try:          data = self.queue.get(block=True, timeout=QUEUE_S_TIMEOUT)          self.handle_data(data)          self.queue.task_done()        except Empty:          continue        except Exception as e:          print(e)      print('Stopped worker thread.')    def on_error(self, status):      '''        Handles API errors.      '''      print('Twitter error: %s' % status)      self.error_status = status      self.stop_queue()      return False    def get_error_status(self):      '''        Returns the API error status if there is one.      '''      return self.error_status    def on_data(self,data):      '''        Puts a task to process new data in queue.      '''      if self.stop_event.is_set():        return False      self.queue.put(data)      return True    def handle_data(self,data):      '''        Sanity check and extract data before sending it to callback.      '''      try:        tweet = json.loads(data)      except ValueError:        print('Failed to decode JSON data: %s' % data)        return      try:        user_id_str = tweet['user']['id_str']        screen_name = tweet['user']['screen_name']      except KeyError:        print('BROKEN tweet: %s' % tweet)        return      if user_id_str != self.user_id:        print('Skipping tweet from user: %s (%s)' % (screen_name, user_id_str))        return      print('Examining tweet: %s' % tweet)      self.callback(tweet['text'])class TwitterListener:    '''        Create a class that inherits StreamListener from tweepy.        Create a Stream object        Use api = self.setup() to set up authentication.        I guess the goal will be to also dump the tweets from each listening session        into an SQL database...        example code can be found here:        https://github.com/dataquestio/twitter-scrape/blob/master/scraper.py    '''    def __init__(self, consumer_key, consumer_secret,                 access_token, access_secret):      '''        init and inherit from StreamListener      '''      self._auth = tweepy.OAuthHandler(consumer_key, consumer_secret)      self._auth.set_access_token(access_token, access_secret)      # self.api = api    def set_endpoint(self, endpoint):    	'''    		Sets endpoints    	'''    	self.endpoint = endpoint    def start_streaming(self, user_id, callback):      '''        Filter to track what you want to stream.      '''      self.stream_listener = StreamListener(user_id, callback=callback)      stream = tweepy.Stream(auth=self._auth, listener=self.stream_listener)      print(egg, 'Starting Twitter Stream for account: {}'.format(user_id))      stream.filter(track=[user_id])      if self.stream_listener and self.stream_listener.get_error_status():        raise Exception(w, 'Twitter API error: {}'.format(self.stream_listener.get_error_status()                        ))    def stop_streaming(self):      '''        Stop stream.      '''      if not self.twitter_listener:        print(w, 'No stream to stop.')        return      print(h,check, 'Stopping Stream. Thank you for using twitterframe.')      self.twitter_listener.stop_queue()      self.twitter_listener = None